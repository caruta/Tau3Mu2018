// -*- C++ -*-
//
// Package:    MiniAna2017/MiniAna2017Tree
// Class:      MiniAna2017Tree
//
/**\class MiniAna2017Tree MiniAna2017Tree.cc MiniAna2017/MiniAna2017Tree/plugins/MiniAna2017Tree.cc
 
 Description: [one line class summary]
 
 Implementation:
 [Notes on implementation]
 */
//
// Original Author:  venditti
//         Created:  Tue, 18 Dec 2018 09:30:06 GMT
//
//


// system include files
#include <memory>
#include <algorithm>
// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/one/EDAnalyzer.h"
#include "FWCore/Framework/interface/ConsumesCollector.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/EventSetup.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/Utilities/interface/EDGetToken.h"
#include "DataFormats/VertexReco/interface/VertexFwd.h"
#include "DataFormats/VertexReco/interface/Vertex.h"
#include <DataFormats/MuonReco/interface/MuonFwd.h>
#include <DataFormats/MuonReco/interface/Muon.h>
#include "DataFormats/PatCandidates/interface/Muon.h"
#include "DataFormats/PatCandidates/interface/Electron.h"
#include "DataFormats/PatCandidates/interface/Tau.h"
#include "DataFormats/PatCandidates/interface/Photon.h"
#include "DataFormats/PatCandidates/interface/Jet.h"
#include "DataFormats/PatCandidates/interface/MET.h"
#include "DataFormats/PatCandidates/interface/PackedCandidate.h"
#include "DataFormats/Candidate/interface/Candidate.h"
#include "FWCore/Utilities/interface/InputTag.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "DataFormats/PatCandidates/interface/PackedGenParticle.h"
#include "FWCore/Framework/interface/ConsumesCollector.h"
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "FWCore/ServiceRegistry/interface/Service.h"
#include "TFile.h"
#include "TH1.h"
#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
#include "TrackingTools/Records/interface/TransientTrackRecord.h"
#include "TH2.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "RecoVertex/KalmanVertexFit/interface/KalmanVertexFitter.h"
#include "RecoVertex/VertexPrimitives/interface/TransientVertex.h"
#include "RecoBTag/SecondaryVertex/interface/SecondaryVertex.h"
#include "RecoVertex/AdaptiveVertexFit/interface/AdaptiveVertexFitter.h"


#include "RecoVertex/KinematicFit/interface/KinematicParticleVertexFitter.h"
#include "RecoVertex/KinematicFitPrimitives/interface/KinematicParticleFactoryFromTransientTrack.h"
#include "RecoVertex/KinematicFit/interface/MassKinematicConstraint.h"
#include "RecoVertex/KinematicFit/interface/KinematicParticleFitter.h"
#include "RecoVertex/KinematicFitPrimitives/interface/MultiTrackKinematicConstraint.h"
#include "RecoVertex/KinematicFit/interface/KinematicConstrainedVertexFitter.h"
#include "RecoVertex/KinematicFit/interface/TwoTrackMassKinematicConstraint.h"
#include "RecoVertex/KinematicFitPrimitives/interface/KinematicParticle.h"
#include "RecoVertex/KinematicFitPrimitives/interface/RefCountedKinematicParticle.h"
#include "RecoVertex/KinematicFitPrimitives/interface/TransientTrackKinematicParticle.h"
#include "RecoVertex/KinematicFitPrimitives/interface/KinematicTree.h"


#include "RecoVertex/KinematicFit/interface/KinematicParticleVertexFitter.h"
#include "RecoVertex/KinematicFit/interface/KinematicParticleFitter.h"
#include "RecoVertex/KinematicFit/interface/MassKinematicConstraint.h"
#include "RecoVertex/KinematicFitPrimitives/interface/KinematicParticle.h"
#include "RecoVertex/KinematicFitPrimitives/interface/RefCountedKinematicParticle.h"
#include "RecoVertex/KinematicFitPrimitives/interface/TransientTrackKinematicParticle.h"
#include "RecoVertex/KinematicFitPrimitives/interface/TransientTrackKinematicParticle.h"
#include "RecoVertex/KinematicFitPrimitives/interface/KinematicParticleFactoryFromTransientTrack.h"
#include "RecoVertex/AdaptiveVertexFit/interface/AdaptiveVertexFitter.h"


#include "TrackingTools/Records/interface/TrackingComponentsRecord.h"

#include "TrackingTools/TransientTrack/interface/TransientTrackFromFTSFactory.h"
#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
#include "TrackingTools/PatternTools/interface/ClosestApproachInRPhi.h"

#include "DataFormats/Candidate/interface/VertexCompositeCandidateFwd.h"
#include "DataFormats/Candidate/interface/CompositeCandidate.h"

#include "RecoVertex/VertexPrimitives/interface/ConvertToFromReco.h"
#include "DataFormats/TrackReco/interface/TrackBase.h"
#include "RecoVertex/VertexTools/interface/VertexDistance3D.h"
#include "SimDataFormats/Vertex/interface/SimVertex.h"
#include "SimDataFormats/Vertex/interface/SimVertexContainer.h"
#include "FWCore/Common/interface/TriggerNames.h"
#include "FWCore/Common/interface/TriggerResultsByName.h"

#include "DataFormats/HLTReco/interface/TriggerEvent.h"
#include "PhysicsTools/PatUtils/interface/TriggerHelper.h"
#include "DataFormats/PatCandidates/interface/TriggerEvent.h"
#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"
#include "DataFormats/PatCandidates/interface/TriggerFilter.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "SimDataFormats/PileupSummaryInfo/interface/PileupSummaryInfo.h"
#include "TrackingTools/IPTools/interface/IPTools.h"


#include "CondFormats/L1TObjects/interface/L1GtTriggerMenu.h"
#include "CondFormats/DataRecord/interface/L1GtTriggerMenuRcd.h"
#include "DataFormats/L1GlobalTrigger/interface/L1GlobalTriggerReadoutRecord.h"
#include "DataFormats/HLTReco/interface/TriggerEvent.h"
#include "FWCore/Common/interface/TriggerNames.h"
#include "DataFormats/Common/interface/TriggerResults.h"
#include "DataFormats/L1TGlobal/interface/GlobalAlgBlk.h"
#include "L1Trigger/L1TGlobal/interface/L1TGlobalUtil.h"
#include "CondFormats/DataRecord/interface/L1TUtmTriggerMenuRcd.h"
#include "CondFormats/L1TObjects/interface/L1TUtmTriggerMenu.h"
#include "CondFormats/DataRecord/interface/L1TGlobalPrescalesVetosRcd.h"
#include "CondFormats/L1TObjects/interface/L1TGlobalPrescalesVetos.h"

#include "DataFormats/TrackReco/interface/TrackToTrackMap.h"
#include "DataFormats/TrackReco/interface/Track.h"
#include "DataFormats/TrackReco/interface/TrackFwd.h"

//#include "DataFormats/BeamSpot/interface/BeamSpot.h"
////
//soft muon Id mva vars taken from:
//https://github.com/cms-sw/cmssw/blob/master/PhysicsTools/PatAlgos/src/SoftMuonMvaEstimator.cc
class MiniAna2017Tree : public edm::one::EDAnalyzer<edm::one::SharedResources>  {
public:
    explicit MiniAna2017Tree(const edm::ParameterSet&);
    ~MiniAna2017Tree();
    static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);
    float dR(float eta1, float eta2, float phi1, float phi2);
    float dRtriggerMatch(pat::Muon m, trigger::TriggerObjectCollection triggerObjects);
    float dPtTriggerMatch(pat::Muon m, trigger::TriggerObjectCollection triggerObjects);
    void beginRun(edm::Run const &, edm::EventSetup const&, edm::Event const&);
    
    
private:
    virtual void beginJob() override;
    virtual void analyze(const edm::Event&, const edm::EventSetup&) override;
    // virtual void beginRun(edm::Run const &, edm::EventSetup const&) override;
    virtual void endJob() override;
    edm::EDGetTokenT<edm::View<pat::Muon> > muons_;
    edm::EDGetTokenT<edm::View<reco::Vertex> > vertex_;
    edm::EDGetTokenT<edm::View<reco::Track> > trackToken_;
    edm::EDGetTokenT<edm::View<reco::CompositeCandidate> > Cand3Mu_;
    edm::EDGetTokenT<edm::View<reco::GenParticle> > genParticles_;
    edm::EDGetTokenT<std::vector<PileupSummaryInfo> > puToken_ ;
    edm::EDGetTokenT<edm::TriggerResults> triggerToken_;
    edm::EDGetTokenT<trigger::TriggerEvent> trigeventToken_;
    edm::EDGetToken algToken_;
  // edm::EDGetTokenT<edm::Handle<reco::BeamSpot> > beamSpotHandle_;
    edm::EDGetTokenT<reco::BeamSpot> token_BeamSpot;
    bool isMc;
    bool isAna;
    bool isBParking;
    const TransientTrackBuilder* theTransientTrackBuilder_;
    HLTConfigProvider hltConfig;
    
    edm::Service<TFileService> fs;
    l1t::L1TGlobalUtil* gtUtil_;
  TH1F *hEvents;
  TH1F *hEventsAfterGoodCand;
  //      TH1F *hEventsAfterGoodCand;
  //    TH1F *hEventsAfterGoodCand;
   edm::InputTag algInputTag_;

    //tree
    TTree*      tree_;
    std::vector<float>  MuonPt, MuonEta, MuonPhi;
    std::vector<double> MuonEnergy,  MuonCharge;
    
    std::vector<int> GenParticle_PdgId, GenParticle_MotherPdgId;
    std::vector<double> GenParticle_Pt, GenParticle_Eta,    GenParticle_Phi;
    
    //Vtx position
    std::vector<double>  Muon_vx,  Muon_vy,  Muon_vz;
    
    //MuonID
  std::vector<double>  Muon_isGlobal,  Muon_isTracker,  Muon_isSoft,  Muon_isLoose, Muon_isTight,  Muon_isPF,  Muon_isRPCMuon,  Muon_isStandAloneMuon,  Muon_isTrackerMuon,  Muon_isCaloMuon,  Muon_isQualityValid,  Muon_isTimeValid,  Muon_isIsolationValid,  Muon_numberOfMatchedStations,  Muon_numberOfMatches, Muon_SoftMVAVal, Muon_LowPtMVA_Val;
    
    //MuonTime
    std::vector<double>  Muon_timeAtIpInOut,Muon_timeAtIpInOutErr;
    
    //Muon inner + outer track
    std::vector<double>  Muon_GLnormChi2, Muon_GLhitPattern_numberOfValidMuonHits,  Muon_trackerLayersWithMeasurement,  Muon_Numberofvalidpixelhits,  Muon_outerTrack_p,  Muon_outerTrack_eta,
    Muon_outerTrack_phi,  Muon_outerTrack_normalizedChi2,  Muon_outerTrack_muonStationsWithValidHits,  Muon_innerTrack_p,  Muon_innerTrack_eta,  Muon_innerTrack_phi,  Muon_innerTrack_normalizedChi2,  Muon_QInnerOuter;
    
  std::vector<double>   Muon_combinedQuality_updatedSta,  Muon_combinedQuality_trkKink,  Muon_combinedQuality_glbKink,  Muon_combinedQuality_trkRelChi2,  Muon_combinedQuality_staRelChi2,  Muon_combinedQuality_chi2LocalPosition,  Muon_combinedQuality_chi2LocalMomentum,  Muon_combinedQuality_localDistance,  Muon_combinedQuality_globalDeltaEtaPhi,  Muon_combinedQuality_tightMatch,  Muon_combinedQuality_glbTrackProbability,  Muon_calEnergy_em,  Muon_calEnergy_emS9,  Muon_calEnergy_emS25,  Muon_calEnergy_had,  Muon_calEnergy_hadS9,  Muon_segmentCompatibility,  Muon_caloCompatibility,  Muon_ptErrOverPt, Muon_BestTrackPt,  Muon_BestTrackPtErr, Muon_BestTrackEta,  Muon_BestTrackEtaErr,  Muon_BestTrackPhi,  Muon_BestTrackPhiErr, Muon_innerTrack_ValidFraction, Muon_Numberofvalidtrackerhits, Muon_IP3D_BS, Muon_IP2D_BS, Muon_IP3D_PV, Muon_IP2D_PV,Muon_validMuonHitComb, Muon_DZ_PV;
  std::vector<double>   Muon_SoftMVA_Val,  MuonLowPtMVA_Val;

  std::vector<bool>  Muon_innerTrack_highPurity;

    std::vector<int>  Muon_simPdgId, Muon_simMotherPdgId, Muon_simFlavour,  Muon_simType, Muon_simBX, Muon_simTpEvent, Muon_simMatchQuality;
    std::vector<double>  Mu1_Pt,  Mu1_Eta,  Mu1_Phi,  Mu2_Pt,  Mu2_Eta,  Mu2_Phi,  Mu3_Pt,  Mu3_Eta,  Mu3_Phi, GenMatchMu1_SimPt, GenMatchMu2_SimPt, GenMatchMu3_SimPt,GenMatchMu1_SimEta, GenMatchMu2_SimEta, GenMatchMu3_SimEta, GenMatchMu1_SimPhi, GenMatchMu2_SimPhi, GenMatchMu3_SimPhi,  GenMatchMu1_Pt,  GenMatchMu2_Pt,  GenMatchMu3_Pt,  GenMatchMu1_Eta,  GenMatchMu2_Eta,  GenMatchMu3_Eta,  GenMatchMu1_Phi,  GenMatchMu2_Phi,  GenMatchMu3_Phi;
    std::vector<float> Mu1_dRtriggerMatch, Mu2_dRtriggerMatch, Mu3_dRtriggerMatch;
  std::vector<float> Mu1_dPtReltriggerMatch, Mu2_dPtReltriggerMatch, Mu3_dPtReltriggerMatch;
 
    std::vector<double>     Muon_emEt03, Muon_hadEt03, Muon_nJets03, Muon_nTracks03, Muon_sumPt03, Muon_emEt05,    Muon_hadEt05, Muon_nJets05, Muon_nTracks05, Muon_sumPt05,
    Muon_hadVetoEt03,Muon_emVetoEt03,    Muon_trackerVetoPt03,    Muon_hadVetoEt05,    Muon_emVetoEt05,    Muon_trackerVetoPt05;
    //dd  Mu1_SimPt,  Mu1_SimEta,  Mu1_SimPhi,  Mu2_SimPt,  Mu2_SimEta,  Mu2_SimPhi, Mu3_SimPt,  Mu3_SimEta,  Mu3_SimPhi,
    
    std::vector<double>     Triplet_mindca_iso, Triplet_relativeiso;
 
    std::vector<int>  Mu1_TripletIndex,  Mu2_TripletIndex,  Mu3_TripletIndex;
    std::vector<int>  Mu1_NTracks03iso,  Mu2_NTracks03iso,  Mu3_NTracks03iso;
    
    int TripletCollectionSize, PVCollection_Size, MuonCollectionSize;
    std::vector<double>  TripletVtx_x,  TripletVtx_y,  TripletVtx_z,  TripletVtx_Chi2,  TripletVtx_NDOF,  Triplet_Mass,  Triplet_Pt,  Triplet_Eta,  Triplet_Phi, Triplet_Charge;
    std::vector<double>     Triplet_relativeiso2, Triplet_IsoMu1, Triplet_IsoMu2,Triplet_IsoMu3;    
    std::vector<double> dxy_mu1, dxy_mu2, dxy_mu3, dxyErr_mu1, dxyErr_mu2, dxyErr_mu3; 
    
    std::vector<double>  RefittedPV_x;
    std::vector<double>  RefittedPV_y;
    std::vector<double>  RefittedPV_z;
    std::vector<double>  RefittedPV_NTracks;
    std::vector<int>     RefittedPV_isValid;
    
    //RefittedPV_Chi2.push_back(PVertex.);
    
    std::vector<double>  FlightDistPVSV;
    std::vector<double>  FlightDistPVSV_Err;
    std::vector<double>  FlightDistPVSV_Significance;
    std::vector<double>  FlightDistPVSV_chi2;

  std::vector<double>   FlightDistBS_SV,  FlightDistBS_SV_Err,  FlightDistBS_SV_Significance;
    
   std::vector<double> PV_x,  PV_y,  PV_z,  PV_NTracks;
  std::vector<int> NGoodTriplets;
    uint  evt, run, lumi, puN;
  std::vector<string>  Trigger_l1name;
  std::vector<int> Trigger_l1decision;
  std::vector<int> Trigger_l1prescale;

  std::vector<string>  Trigger_hltname;
  std::vector<int> Trigger_hltdecision;
  std::vector<double> MuonPt_HLT,  MuonEta_HLT,  MuonPhi_HLT;
  std::vector<double> MuonPt_HLT2017, MuonEta_HLT2017, MuonPhi_HLT2017, MuonPt_HLT_BPMu7, MuonEta_HLT_BPMu7, MuonPhi_HLT_BPMu7, MuonPt_HLT_BPMu8, MuonEta_HLT_BPMu8, MuonPhi_HLT_BPMu8, MuonPt_HLT_BPMu8_IP6,  MuonEta_HLT_BPMu8_IP6, MuonPhi_HLT_BPMu8_IP6, MuonPt_HLT_BPMu8_IP5, MuonEta_HLT_BPMu8_IP5, MuonPhi_HLT_BPMu8_IP5,   MuonPt_HLT_BPMu9_IP0, MuonEta_HLT_BPMu9_IP0, MuonPhi_HLT_BPMu9_IP0, MuonPt_HLT_BPMu3_IP3, MuonEta_HLT_BPMu3_IP3, MuonPhi_HLT_BPMu3_IP3, MuonPt_HLT_BPMu3_IP4,MuonEta_HLT_BPMu3_IP4,MuonPhi_HLT_BPMu3_IP4,MuonPt_HLT_BPMu3_IP5, MuonEta_HLT_BPMu3_IP5,MuonPhi_HLT_BPMu3_IP5,MuonPt_HLT_BPMu3_IP6,MuonEta_HLT_BPMu3_IP6,MuonPhi_HLT_BPMu3_IP6,MuonPt_HLT_BPMu12_IP6,MuonEta_HLT_BPMu12_IP6,MuonPhi_HLT_BPMu12_IP6;

  std::vector<float> Mu1_dRtriggerMatch_Mu8_IP5, Mu1_dRtriggerMatch_Mu8_IP6, Mu1_dRtriggerMatch_Mu9_IP0, Mu1_dRtriggerMatch_Mu9_IP3, Mu1_dRtriggerMaTch_Mu9_IP4, Mu1_dRtriggerMatch_Mu9_IP5, Mu1_dRtriggerMatch_Mu9_IP6, Mu1_dRtriggerMatch_Mu12_IP6,Mu1_dRtriggerMatch_Mu9_IP4;
  std::vector<float> Mu1_dRtriggerMatch_Mu7, Mu2_dRtriggerMatch_Mu7, Mu3_dRtriggerMatch_Mu7;
  std::vector<float> Mu1_dRtriggerMatch_Mu8, Mu2_dRtriggerMatch_Mu8, Mu3_dRtriggerMatch_Mu8;

    //Synctree
    /*  TTree*      SyncTree_;
     std::vector<float>  allmuons_pt, leadmuon_pt, leadmuon_phi, leadmuon_eta;
     std::vector<float>  alltracks_pt, leadtrack_pt,  leadtrack_eta,  leadtrack_phi;
     uint nprimevtxs, nmuons, evt, run, lumi;
     */
    };
    
    
    
    MiniAna2017Tree::MiniAna2017Tree(const edm::ParameterSet& iConfig){
        edm::InputTag algInputTag_;
        isMc = iConfig.getUntrackedParameter<bool>("isMcLabel");
	isAna = iConfig.getUntrackedParameter<bool>("isAnaLabel");
	isBParking= iConfig.getUntrackedParameter<bool>("isBParkingLabel");
        muons_ = consumes<edm::View<pat::Muon> >  (iConfig.getParameter<edm::InputTag>("muonLabel"));
        vertex_ = consumes<edm::View<reco::Vertex> > (iConfig.getParameter<edm::InputTag>("VertexLabel"));
        trackToken_ = consumes<edm::View<reco::Track> > (edm::InputTag("generalTracks"));
        genParticles_ = consumes<edm::View<reco::GenParticle>  > (iConfig.getParameter<edm::InputTag>("genParticleLabel"));
        Cand3Mu_ = consumes<edm::View<reco::CompositeCandidate> > (iConfig.getParameter<edm::InputTag>("Cand3MuLabel"));
        puToken_ =   consumes<std::vector<PileupSummaryInfo> >(iConfig.getParameter<edm::InputTag>("pileupSummary"));
	triggerToken_ = consumes<edm::TriggerResults>(iConfig.getParameter<edm::InputTag>("triggerResults"));
	trigeventToken_ = consumes<trigger::TriggerEvent>(iConfig.getParameter<edm::InputTag>("triggerSummary"));
	algToken_ = consumes<BXVector<GlobalAlgBlk>>(iConfig.getParameter<edm::InputTag>("AlgInputTag"));
	gtUtil_ = new l1t::L1TGlobalUtil(iConfig, consumesCollector(), *this, algInputTag_, algInputTag_);
	//beamSpotHandle_  = consumes<edm::Handle<reco::BeamSpot> > (edm::InputTag("offlineBeamSpot"));
	token_BeamSpot = consumes<reco::BeamSpot>(edm::InputTag("offlineBeamSpot"));
        //  _hltInputTag(iConfig.getParameter<edm::InputTag>("hltInputTag")),
        //tauToken_(consumes(iConfig.getParameter("taus"))),
        //metToken_(consumes(iConfig.getParameter("mets")))

    }
    MiniAna2017Tree::~MiniAna2017Tree()
    {
        
        // do anything here that needs to be done at desctruction time
        // (e.g. close files, deallocate resources etc.)
    }
    
    
    float MiniAna2017Tree::dR(float eta1, float eta2, float phi1, float phi2){
        float dphi=(phi1-phi2);
        float deta=(eta1-eta2);
        float deltaR= TMath::Sqrt(dphi*dphi + deta*deta);
        return deltaR;
    }

    float MiniAna2017Tree::dRtriggerMatch(pat::Muon m, trigger::TriggerObjectCollection triggerObjects) {
        float dRmin = 1.;                                                                          
        for (unsigned int i = 0 ; i < triggerObjects.size() ; i++) {
            float deltaR = sqrt( reco::deltaR2(triggerObjects[i].eta(), triggerObjects[i].phi(), m.eta(), m.phi()));
            //float deltaR = sqrt( pow(triggerObjects[i].eta() - m.eta(), 2) + pow(acos(cos(triggerObjects[i].phi() - m.phi())), 2));
            if (deltaR < dRmin) dRmin = deltaR;                                                    
        }                                                                                          
        return dRmin;                                                                              
    }
float MiniAna2017Tree::dPtTriggerMatch(pat::Muon m, trigger::TriggerObjectCollection triggerObjects) {
  float dPtmin = 10000.;
  for (unsigned int i = 0 ; i < triggerObjects.size() ; i++) {
    float deltaPtRel = (triggerObjects[i].pt() - m.pt())/m.pt();
    //float deltaPtMin = sqrt( reco::deltaR2(triggerObjects[i].eta(), triggerObjects[i].phi(), m.eta(), m.phi()));
    //float deltaR = sqrt( pow(triggerObjects[i].eta() - m.eta(), 2) + pow(acos(cos(triggerObjects[i].phi() - m.phi())), 2));                 
    if (deltaPtRel < dPtmin) dPtmin = deltaPtRel;
  }
  return dPtmin;
}

    
    bool isGoodTrack(const reco::Track &track) {
        if(track.pt()>1){
            if(std::fabs(track.eta())<2.4){
                if(track.hitPattern().trackerLayersWithMeasurement()>5){
                    if(track.hitPattern().pixelLayersWithMeasurement()>1) return true;
                }
            }
        }
        return false;
    }
    
    typedef std::map<const reco::Track*, reco::TransientTrack> TransientTrackMap;
    // auxiliary function to exclude tracks associated to tau lepton decay "leg"
    // from primary event vertex refit
    bool tracksMatchByDeltaR(const reco::Track* trk1, const reco::Track* trk2)
    {
        if ( reco::deltaR(*trk1, *trk2) < 1.e-2 && trk1->charge() == trk2->charge() ) return true;
        else return false;
    }
    
    void removeTracks(TransientTrackMap& pvTracks_toRefit, const std::vector<reco::Track*> svTracks)
    {
        for ( std::vector<reco::Track*>::const_iterator svTrack = svTracks.begin(); svTrack != svTracks.end(); ++svTrack ){
            //--- remove track from list of tracks included in primary event vertex refit
            //    if track matches by reference or in eta-phi
            //    any of the tracks associated to tau lepton decay "leg"
            for ( TransientTrackMap::iterator pvTrack = pvTracks_toRefit.begin(); pvTrack != pvTracks_toRefit.end(); ++pvTrack ) {
                if ( tracksMatchByDeltaR(pvTrack->first, *svTrack) ) {
                    pvTracks_toRefit.erase(pvTrack);
                    break;
                }
            }
        }
    }
    
    
    
    void MiniAna2017Tree::beginRun(edm::Run const& iRun, edm::EventSetup const& iSetup, const edm::Event& iEvent) {
      /*  
      edm::Handle<edm::TriggerResults> trigResults; //our trigger result object
        edm::InputTag trigResultsTag("TriggerResults"," ","HLT"); //make sure have correct process on MC
        iEvent.getByLabel(trigResultsTag,trigResults);
        
        bool changed = true;
        if (hltConfig.init(iRun, iSetup, trigResultsTag.process(), changed)) {
            // if init returns TRUE, initialisation has succeeded!
            std::cout << "HLT config with process name "<< trigResultsTag.process() << " successfully extracted"<<std::endl;
        }
        else {
            // if init returns FALSE, initialisation has NOT succeeded, which indicates a problem
            // with the file and/or code and needs to be investigated!
            std::cout << "Error! HLT config extraction with process name " << trigResultsTag.process() << " failed"<<std::endl;
            // In this case, all access methods will return empty values!
        }
      */
    }
    
    
    
    void
    MiniAna2017Tree::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
    {
        using namespace edm;
        using namespace std;
        using namespace reco;
        using std::vector;
        
        

        edm::Handle< edm::View<reco::Vertex> >vertices;
        iEvent.getByToken(vertex_, vertices);
        if (vertices->empty()) return; // skip the event if no PV found
        const reco::Vertex &PV = vertices->front();
        
        edm::Handle< edm::View<pat::Muon> > muons;
        iEvent.getByToken(muons_, muons);
        
        
        edm::Handle<edm::View<reco::CompositeCandidate> > Cand3Mu;
        iEvent.getByToken(Cand3Mu_, Cand3Mu);
        
        
        edm::Handle< edm::View<reco::GenParticle> > genParticles;
        iEvent.getByToken(genParticles_, genParticles);
        
        
        edm::Handle<edm::View<reco::Track> > trackCollection;
        iEvent.getByToken(trackToken_, trackCollection);
        
	Handle<TriggerResults> triggerResults;
	iEvent.getByToken(triggerToken_, triggerResults);

	Handle<trigger::TriggerEvent> triggerSummary;
	iEvent.getByToken(trigeventToken_, triggerSummary);

	Handle<BXVector<GlobalAlgBlk>> alg;
	iEvent.getByToken(algToken_,alg);

	edm::ESHandle<TransientTrackBuilder> theTransientTrackBuilder;
        iSetup.get<TransientTrackRecord>().get("TransientTrackBuilder",theTransientTrackBuilder);
        theTransientTrackBuilder_ = theTransientTrackBuilder.product();


	/*	reco::BeamSpot beamSpot;
	edm::Handle<reco::BeamSpot> beamSpotHandle;
	iEvent.getByToken(beamSpotHandle_, beamSpotHandle);
	*/

	reco::BeamSpot beamSpot;
	edm::Handle<reco::BeamSpot> beamSpotHandle;
	iEvent.getByToken(token_BeamSpot, beamSpotHandle);
	const reco::BeamSpot& beamspot = *beamSpotHandle.product();
	


	if ( beamSpotHandle.isValid() )
	  {
	    beamSpot = *beamSpotHandle;

	  } else
	  {
	    edm::LogInfo("MyAnalyzer")
	      << "No beam spot available from EventSetup \n";
	  }

	//edm::Handle<SimTrackContainer> simTracks;
	//iEvent.getByLabel("g4SimHits",simTracks);

        hEvents->Fill(1);


	///////////////Fill Trigger Vars, L1 and HLT///////////////

	gtUtil_->retrieveL1(iEvent, iSetup, algToken_);
	const vector<pair<string, bool> > initialDecisions = gtUtil_->decisionsInitial();
	
	if (!iEvent.isRealData())
	  {
	    for (size_t i_l1t = 0; i_l1t < initialDecisions.size(); i_l1t++) 
	      {
		string l1tName = (initialDecisions.at(i_l1t)).first;
		if(l1tName.find("DoubleMu") != string::npos || l1tName.find("TripleMu") != string::npos || l1tName.find("SingleMu")){
		  //cout<<"MC: L1 name="<<l1tName<<endl;
		  Trigger_l1name.push_back( l1tName );
		  Trigger_l1decision.push_back( initialDecisions.at(i_l1t).second );
		  Trigger_l1prescale.push_back( 1 );
		}
	      }
	  }
	else
	  {
	    ESHandle<L1TGlobalPrescalesVetos> psAndVetos;
	    auto psRcd = iSetup.tryToGet<L1TGlobalPrescalesVetosRcd>();
	    if(psRcd) psRcd->get(psAndVetos);
	    int columnN= gtUtil_->prescaleColumn();
	    for (size_t i_l1t = 0; i_l1t < initialDecisions.size(); i_l1t++) {
	      string l1tName = (initialDecisions.at(i_l1t)).first;
	      if(l1tName.find("DoubleMu") != string::npos || l1tName.find("TripleMu") != string::npos || l1tName.find("SingleMu")){
		//cout<<"Data: L1Seed="<<l1tName<<" decision="<<initialDecisions.at(i_l1t).second<<endl;
		Trigger_l1name.push_back( l1tName );
		Trigger_l1decision.push_back( initialDecisions.at(i_l1t).second );
		Trigger_l1prescale.push_back( (psAndVetos->prescale_table_)[columnN][i_l1t]);
                }
            }
        }
        
            
	const TriggerNames &triggerNames = iEvent.triggerNames( *triggerResults );
	for (size_t i_hlt = 0; i_hlt != triggerResults->size(); ++i_hlt){
	    string hltName = triggerNames.triggerName(i_hlt);
	    if( (hltName.find("HLT_DoubleMu") != string::npos) || (hltName.find("HLT_Mu8_IP") != string::npos) || (hltName.find("HLT_Mu7_IP")!= string::npos) ||     (hltName.find("HLT_Mu9_IP")   != string::npos) || (hltName.find("HLT_Mu12_IP")!=string::npos) ){
	      
	      //cout<<" HLTPath="<<hltName<<" isPassed="<<triggerResults->accept(i_hlt )<<endl;
	      Trigger_hltname.push_back(hltName);
	      Trigger_hltdecision.push_back(triggerResults->accept(i_hlt ));
	    }
	}


	std::vector<trigger::TriggerObject> trgobjs = triggerSummary->getObjects();
	trigger::TriggerObjectCollection MuonsObjects;
	trigger::TriggerObjectCollection MuonsObjects_BPMu7, MuonsObjects_BPMu12_IP6;
	trigger::TriggerObjectCollection MuonsObjects_BPMu8, MuonsObjects_BPMu8_IP6, MuonsObjects_BPMu8_IP5;
	trigger::TriggerObjectCollection MuonsObjects_BPMu9_IP0, MuonsObjects_BPMu9_IP6, MuonsObjects_BPMu9_IP4, MuonsObjects_BPMu9_IP5, MuonsObjects_BPMu9_IP3;

	edm::InputTag MuonFilterTag = edm::InputTag("hltdstau3muDisplaced3muFltr", "", "HLT");
        size_t MuonFilterIndex = (*triggerSummary).filterIndex(MuonFilterTag); //find the index corresponding to the event                          

        if(MuonFilterIndex < (*triggerSummary).sizeFilters()) { 
          const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex);
          for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
            MuonsObjects.push_back(foundObject);
          }
        }
	for(unsigned int i = 0 ; i <MuonsObjects.size() ; i++) {
	  MuonPt_HLT.push_back(MuonsObjects[i].pt());
	  MuonEta_HLT.push_back(MuonsObjects[i].eta());
	  MuonPhi_HLT.push_back(MuonsObjects[i].phi());
	  
	}

	if( isBParking){
	edm::InputTag MuonFilterTagBPHMu8 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered8Q", "", "HLT");
	edm::InputTag MuonFilterTagBPHMu7 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered7IP4Q", "", "HLT");

	edm::InputTag MuonFilterTagBPHMu8_IP5 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered8IP5Q", "", "HLT");
	edm::InputTag MuonFilterTagBPHMu8_IP6 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered8IP6Q", "", "HLT");

	edm::InputTag MuonFilterTagBPHMu9_IP0 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered9IP0Q", "", "HLT");
	edm::InputTag MuonFilterTagBPHMu9_IP3 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered9IP3Q", "", "HLT");
	edm::InputTag MuonFilterTagBPHMu9_IP4 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered9IP4Q", "", "HLT");
	edm::InputTag MuonFilterTagBPHMu9_IP5 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered9IP5Q", "", "HLT");
	edm::InputTag MuonFilterTagBPHMu9_IP6 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered9Q", "", "HLT");
	edm::InputTag MuonFilterTagBPHMu12_IP6 = edm::InputTag("hltL3fL1sMu22OrParkL1f0L2f10QL3Filtered12Q", "", "HLT");

	size_t MuonFilterIndex_BPHMu8 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu8);
	size_t MuonFilterIndex_BPHMu7 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu7);
	size_t MuonFilterIndex_BPHMu8_IP5 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu8_IP5);
	size_t MuonFilterIndex_BPHMu8_IP6 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu8_IP6);
	size_t MuonFilterIndex_BPHMu9_IP0 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu9_IP0);
	size_t MuonFilterIndex_BPHMu9_IP3 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu9_IP3);
	size_t MuonFilterIndex_BPHMu9_IP4 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu9_IP4);
	size_t MuonFilterIndex_BPHMu9_IP5 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu9_IP5);
	size_t MuonFilterIndex_BPHMu9_IP6 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu9_IP6);
	size_t MuonFilterIndex_BPHMu12_IP6 = (*triggerSummary).filterIndex(MuonFilterTagBPHMu12_IP6);


	if(MuonFilterIndex_BPHMu8 < (*triggerSummary).sizeFilters()) {
          const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu8);
          for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
            MuonsObjects_BPMu8.push_back(foundObject);
          }
        }


	if(MuonFilterIndex_BPHMu7 < (*triggerSummary).sizeFilters()) {
          const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu7);
          for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
            MuonsObjects_BPMu7.push_back(foundObject);
          }
        }

	if(MuonFilterIndex_BPHMu8_IP6 < (*triggerSummary).sizeFilters()) {
          const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu8_IP6);
          for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
            MuonsObjects_BPMu8_IP6.push_back(foundObject);
          }
        }

	if(MuonFilterIndex_BPHMu8_IP5 < (*triggerSummary).sizeFilters()) {
          const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu8_IP5);
          for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
            MuonsObjects_BPMu8_IP5.push_back(foundObject);
          }
        }


	if(MuonFilterIndex_BPHMu9_IP0 < (*triggerSummary).sizeFilters()) {
          const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu9_IP0);
          for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
            MuonsObjects_BPMu9_IP0.push_back(foundObject);
          }
        }


	if(MuonFilterIndex_BPHMu9_IP3 < (*triggerSummary).sizeFilters()) {
	  const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu9_IP3);
	  for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
	    MuonsObjects_BPMu9_IP3.push_back(foundObject);

	  }
	}


	if(MuonFilterIndex_BPHMu9_IP4 < (*triggerSummary).sizeFilters()) {
	  const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu9_IP4);
	  for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
	    MuonsObjects_BPMu9_IP4.push_back(foundObject);
	  }
	}


	if(MuonFilterIndex_BPHMu9_IP5 < (*triggerSummary).sizeFilters()) {
          const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu9_IP5);
          for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
            MuonsObjects_BPMu9_IP5.push_back(foundObject);
          }
	}


	if(MuonFilterIndex_BPHMu9_IP6 < (*triggerSummary).sizeFilters()) {
          const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu9_IP6);
          for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
            MuonsObjects_BPMu9_IP6.push_back(foundObject);

          }
        }


	if(MuonFilterIndex_BPHMu12_IP6 < (*triggerSummary).sizeFilters()) {
	  const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex_BPHMu12_IP6);
	  for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
	    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
	    MuonsObjects_BPMu12_IP6.push_back(foundObject);
	  }
	}


	
	for(uint t=0; t<MuonsObjects_BPMu7.size();t++){
          MuonPt_HLT_BPMu7.push_back(MuonsObjects_BPMu7.at(t).pt());
          MuonEta_HLT_BPMu7.push_back(MuonsObjects_BPMu7.at(t).eta());
          MuonPhi_HLT_BPMu7.push_back(MuonsObjects_BPMu7.at(t).phi());
        }


	  for(uint t=0; t<MuonsObjects_BPMu8.size();t++){
	    MuonPt_HLT_BPMu8.push_back(MuonsObjects_BPMu8.at(t).pt());
	    MuonEta_HLT_BPMu8.push_back(MuonsObjects_BPMu8.at(t).eta());
	    MuonPhi_HLT_BPMu8.push_back(MuonsObjects_BPMu8.at(t).phi());
	  }

	  for(uint t=0; t<MuonsObjects_BPMu8_IP6.size();t++){
	    MuonPt_HLT_BPMu8_IP6.push_back(MuonsObjects_BPMu8_IP6.at(t).pt());
	    MuonEta_HLT_BPMu8_IP6.push_back(MuonsObjects_BPMu8_IP6.at(t).eta());
	    MuonPhi_HLT_BPMu8_IP6.push_back(MuonsObjects_BPMu8_IP6.at(t).phi());
	  }

	  for(uint t=0; t<MuonsObjects_BPMu8_IP5.size();t++){
	    MuonPt_HLT_BPMu8_IP5.push_back(MuonsObjects_BPMu8_IP5.at(t).pt());
	    MuonEta_HLT_BPMu8_IP5.push_back(MuonsObjects_BPMu8_IP5.at(t).eta());
	    MuonPhi_HLT_BPMu8_IP5.push_back(MuonsObjects_BPMu8_IP5.at(t).phi());
	  }

	  for(uint t=0; t<MuonsObjects_BPMu9_IP0.size();t++){
	    MuonPt_HLT_BPMu9_IP0.push_back(MuonsObjects_BPMu9_IP0.at(t).pt());
	    MuonEta_HLT_BPMu9_IP0.push_back(MuonsObjects_BPMu9_IP0.at(t).eta());
	    MuonPhi_HLT_BPMu9_IP0.push_back(MuonsObjects_BPMu9_IP0.at(t).phi());
	  }

	  for(uint t=0; t< MuonsObjects_BPMu9_IP3.size();t++){
	    MuonPt_HLT_BPMu3_IP3.push_back(MuonsObjects_BPMu9_IP3.at(t).pt());
	    MuonEta_HLT_BPMu3_IP3.push_back(MuonsObjects_BPMu9_IP3.at(t).eta());
	    MuonPhi_HLT_BPMu3_IP3.push_back(MuonsObjects_BPMu9_IP3.at(t).phi());
	  }
	  for(uint t=0; t< MuonsObjects_BPMu9_IP4.size();t++){
	    MuonPt_HLT_BPMu3_IP4.push_back(MuonsObjects_BPMu9_IP4.at(t).pt());
	    MuonEta_HLT_BPMu3_IP4.push_back(MuonsObjects_BPMu9_IP4.at(t).eta());
	    MuonPhi_HLT_BPMu3_IP4.push_back(MuonsObjects_BPMu9_IP4.at(t).phi());

	  }

	  for(uint t=0; t< MuonsObjects_BPMu9_IP5.size();t++){
	    MuonPt_HLT_BPMu3_IP5.push_back(MuonsObjects_BPMu9_IP5.at(t).pt());
	    MuonEta_HLT_BPMu3_IP5.push_back(MuonsObjects_BPMu9_IP5.at(t).eta());
	    MuonPhi_HLT_BPMu3_IP5.push_back(MuonsObjects_BPMu9_IP5.at(t).phi());
	  }
	  for(uint t=0; t< MuonsObjects_BPMu9_IP6.size();t++){
	    MuonPt_HLT_BPMu3_IP6.push_back(MuonsObjects_BPMu9_IP6.at(t).pt());
	    MuonEta_HLT_BPMu3_IP6.push_back(MuonsObjects_BPMu9_IP6.at(t).eta());
	    MuonPhi_HLT_BPMu3_IP6.push_back(MuonsObjects_BPMu9_IP6.at(t).phi());

	  }

	  for(uint t=0; t< MuonsObjects_BPMu12_IP6.size();t++){
	    MuonPt_HLT_BPMu12_IP6.push_back(MuonsObjects_BPMu12_IP6.at(t).pt());
	    MuonEta_HLT_BPMu12_IP6.push_back(MuonsObjects_BPMu12_IP6.at(t).eta());
	    MuonPhi_HLT_BPMu12_IP6.push_back(MuonsObjects_BPMu12_IP6.at(t).phi());
	  }

	}

 
	///////////////Fill GenParticles///////////////
        if(isMc){
            uint j=0;
            uint ngenP=genParticles->size();
            std::vector<int> genPidx;
            //uint tauRaw=-999; //int DsRaw=-999;
            
	    //            cout<<"****************GenLevel Info Begin********************"<<endl;
            for(edm::View<reco::GenParticle>::const_iterator gp=genParticles->begin(); gp!=genParticles->end(), j<ngenP; ++gp , ++j){
                //if(fabs(gp->pdgId())==15) tauRaw = j;
                
	      if(fabs(gp->pdgId())==13 || fabs(gp->pdgId())==15  || fabs(gp->pdgId())==11 || fabs(gp->pdgId())==211 || fabs(gp->pdgId())==321 ||  fabs(gp->pdgId())==12  || fabs(gp->pdgId())==14 || fabs(gp->pdgId())==16 || fabs(gp->pdgId())==431 || fabs(gp->pdgId())==511 || fabs(gp->pdgId())==521) {
                    GenParticle_PdgId.push_back(gp->pdgId());
                    GenParticle_Pt.push_back(gp->pt());
                    GenParticle_Eta.push_back(gp->eta());
                    GenParticle_Phi.push_back(gp->phi());
                    if (gp->numberOfMothers()) {GenParticle_MotherPdgId.push_back(gp->mother(0)->pdgId());
                    }else{
                        GenParticle_MotherPdgId.push_back(-99);
                    }
                    for (uint i=0; i<gp->numberOfMothers();i++){
                        if(fabs(gp->mother(i)->pdgId())==15) {
			  //std::cout<<j<<"--genMu pt="<<gp->pt()<<" eta="<<gp->eta()<<" phi="<<gp->phi()<<" pdgID="<<gp->pdgId()<<" tau pt="<<gp->mother(i)->pt()<<" mu vtx_x="<<gp->vx()<<" mu vtx_y="<<gp->vy()<<" mu vtx_z="<<gp->vz()<<endl;
                            //cout<<tauRaw<<"--mother pdgID="<<gp->mother(i)->pdgId()<<" mother vtx_x="<<gp->mother(i)->vx()<<" vy="<<gp->mother(i)->vy()<<" vz="<<gp->mother(i)->vz()<<endl;
                            //cout<<"TauMother pdgId="<<gp->mother(i)->mother(0)->pdgId()<<" vx="<<gp->mother(i)->mother(0)->vx()<<" vy="<<gp->mother(i)->mother(0)->vy()<<" vz="<<gp->mother(i)->mother(0)->vz()<<endl;
                            genPidx.push_back(j);
                        }
                    }
                }
            }
            
	    //            cout<<"****************GenLevel Info End ********************"<<endl;
        }
        ///////////////Fill GenParticles///////////////
        
        //Primary Vtx
	//  const reco::Vertex* eventVertex;

        PVCollection_Size = vertices->size();
        //cout<<" PV size ="<<vertices->size()<<endl;

	//std::vector<TransientTrackMap> pvTrackMap_refitVec;	
	//for (reco::VertexCollection::const_iterator it = vertices.begin(); it != vertices.end() && VtxIt != vertices->size() ; ++it, ++VtxIt) {
	//for(uint VtxIt =0;VtxIt<vertices->size();VtxIt++ ){
	//std::vector<reco::TransientTrack> pvTracks_original2;
	//TransientTrackMap pvTrackMap_refit2;
	//for ( reco::Vertex::trackRef_iterator pvTrack =  (*vertices)[VtxIt].tracks_begin(); pvTrack != (*vertices)[VtxIt].tracks_end(); ++pvTrack ) {
	    //cout<<" pv track size"<<(*vertices)[VtxIt].tracks_size()<<endl;
	    //reco::TransientTrack pvTrack_transient =theTransientTrackBuilder_->build(pvTrack->get());
            //pvTracks_original2.push_back(pvTrack_transient);
            //pvTrackMap_refit2.insert(std::make_pair(pvTrack->get(), pvTrack_transient));
	    //pvTrackMap_refitVec.push_back(pvTrackMap_refit2);
	//}
	//cout<<"Vtx id="<<VtxIt<<" Number of tracks associated to the PV="<<pvTracks_original2.size()<<endl;
	//}
	
	
        //Triplets  Loop
        //cout<<"Number Of Triplets="<<Cand3Mu->size()<<endl;
	std::vector<int> NTripl;
	if(isAna){
        TripletCollectionSize = Cand3Mu->size() ;
        int TripletIndex =-99; uint trIn=0;
        for(edm::View<reco::CompositeCandidate>::const_iterator TauIt=Cand3Mu->begin(); TauIt!=Cand3Mu->end(), trIn<Cand3Mu->size(); ++TauIt, ++trIn){

	  const Candidate * c1 = TauIt->daughter(0)->masterClone().get();
	  const pat::Muon *mu1 = dynamic_cast<const pat::Muon *>(c1);
	  
	  const Candidate * c2 = TauIt->daughter(1)->masterClone().get();
	  const pat::Muon *mu2 = dynamic_cast<const pat::Muon *>(c2);
		
	  const Candidate * c3 = TauIt->daughter(2)->masterClone().get();
	  const pat::Muon *mu3 = dynamic_cast<const pat::Muon *>(c3);



            TrackRef trk1, trk2, trk3;
            if (mu1->isGlobalMuon()) { trk1 = mu1->get<TrackRef,reco::CombinedMuonTag>();}
            else { trk1 = mu1->get<TrackRef>();}
            if (mu2->isGlobalMuon()) { trk2 = mu2->get<TrackRef,reco::CombinedMuonTag>();}
            else{ trk2 = mu2->get<TrackRef>();}
            if (mu3->isGlobalMuon()) { trk3 = mu3->get<TrackRef,reco::CombinedMuonTag>();}
            else{  trk3 = mu3->get<TrackRef>();}
            //cout<<" trk1 id="<<trk1.id()<<" tr2:"<<trk2.id()<<" trk3="<<trk3.id()<<endl;
            const reco::TransientTrack transientTrack1=theTransientTrackBuilder_->build( trk1 );
            const reco::TransientTrack transientTrack2=theTransientTrackBuilder_->build( trk2 );
            const reco::TransientTrack transientTrack3=theTransientTrackBuilder_->build( trk3 );
            reco::Track Track1 =transientTrack1.track();
            reco::Track Track2 =transientTrack2.track();
            reco::Track Track3 =transientTrack3.track();
            reco::Track* TrackRef1=&Track1;
            reco::Track* TrackRef2=&Track2;
            reco::Track* TrackRef3=&Track3;
            vector<reco::Track*> SVTrackRef;
            SVTrackRef.push_back(TrackRef1);
            SVTrackRef.push_back(TrackRef2);
            SVTrackRef.push_back(TrackRef3);



            reco::Vertex TripletVtx = reco::Vertex(TauIt->vertex(), TauIt->vertexCovariance(), TauIt->vertexChi2(), TauIt->vertexNdof(), TauIt->numberOfDaughters() );
	    double dphi_pv = -1.0;
	    uint primaryvertex_index=0;
	    TLorentzVector ThreeCandidate;
	    ThreeCandidate.SetPtEtaPhiM(TauIt->pt(), TauIt->eta(), TauIt->phi(), TauIt->mass());


	    for(uint VtxIt =0;VtxIt<vertices->size();VtxIt++ ){
	      //cout<<"Vtx id="<<VtxIt<<" x="<<(*vertices)[VtxIt].x()<<endl;
	      TVector3 Dv3D_reco(TripletVtx.x() - (*vertices)[VtxIt].x(), TripletVtx.y() - (*vertices)[VtxIt].y(), TripletVtx.z() - (*vertices)[VtxIt].z());
	      double Cosdphi_3D = Dv3D_reco.Dot(ThreeCandidate.Vect())/(Dv3D_reco.Mag()*ThreeCandidate.Vect().Mag());
	      if(Cosdphi_3D>dphi_pv){
		dphi_pv = Cosdphi_3D;
		primaryvertex_index=VtxIt;
	      }
	    }


	    std::vector<reco::TransientTrack> pvTracks_original;
	    TransientTrackMap pvTrackMap_refit;

	    for ( reco::Vertex::trackRef_iterator pvTrack = (*vertices)[primaryvertex_index].tracks_begin(); pvTrack != (*vertices)[primaryvertex_index].tracks_end(); ++pvTrack ) {
	      reco::TransientTrack pvTrack_transient =theTransientTrackBuilder_->build(pvTrack->get());
	      pvTracks_original.push_back(pvTrack_transient);
	      pvTrackMap_refit.insert(std::make_pair(pvTrack->get(), pvTrack_transient));
	    }

	    removeTracks(pvTrackMap_refit,  SVTrackRef);
	    std::vector<reco::TransientTrack> pvTracks_refit;
            for ( TransientTrackMap::iterator pvTrack = pvTrackMap_refit.begin();  pvTrack != pvTrackMap_refit.end(); ++pvTrack ) {
	      pvTracks_refit.push_back(pvTrack->second);}


	    //cout<<" Closest PV index "<<primaryvertex_index<<" x="<<(*vertices)[primaryvertex_index].x()<<" y="<<(*vertices)[primaryvertex_index].y()<<" z="<<(*vertices)[primaryvertex_index].z()<<endl;

	    //std::vector<reco::transientTrack> pvtracks_original;
	    //Transienttrackmap Pvtrackmap_Refit;

	    //For ( reco::Vertex::trackRef_iterator pvTrack = (*vertices)[primaryvertex_index].tracks_begin(); pvTrack != (*vertices)[primaryvertex_index].tracks_end(); ++pvTrack ) {
	    // reco::TransientTrack pvTrack_transient =theTransientTrackBuilder_->build(pvTrack->get());
	    //  pvTracks_original.push_back(pvTrack_transient);
	    //  pvTrackMap_refit.insert(std::make_pair(pvTrack->get(), pvTrack_transient));
	    //}
	    RefittedPV_NTracks.push_back(pvTracks_refit.size());   

            if(pvTracks_refit.size() >1){
	      KalmanVertexFitter PV_fitter (true);
	      TransientVertex PVertex = PV_fitter.vertex(pvTracks_refit);
		
	      RefittedPV_isValid.push_back(PVertex.isValid());
                
	      //cout<<"Valid Vtx1="<<PVertex.isValid()<<endl;
	      if(PVertex.isValid()){

		NTripl.push_back(1);
            
		TripletIndex=trIn;
		//    if (!(TauIt->vertexChi2() < 20)) continue ;
		//    TripletsCounter.push_back(1);
            
		//Daughter Kinematics at reco+gen level
            
            Mu1_Pt.push_back(mu1->pt());
            Mu1_Eta.push_back(mu1->eta());
            Mu1_Phi.push_back(mu1->phi());
            Mu1_TripletIndex.push_back(TripletIndex);
            
            Mu2_Pt.push_back(mu2->pt());
            Mu2_Eta.push_back(mu2->eta());
            Mu2_Phi.push_back(mu2->phi());
            Mu2_TripletIndex.push_back(TripletIndex);
            
            Mu3_Pt.push_back(mu3->pt());
            Mu3_Eta.push_back(mu3->eta());
            Mu3_Phi.push_back(mu3->phi());
            Mu3_TripletIndex.push_back(TripletIndex);
            //cout<<"Reco mu1 pt="<<mu1->pt()<<" mu2 pt="<<mu2->pt()<<" mu3 pt="<<mu3->pt()<<endl;
            

            //TransientVertex TransientTripletVtx = reco::Vertex(TauIt->vertex(), TauIt->vertexCovariance(), TauIt->vertexChi2(), TauIt->vertexNdof(), TauIt->numberOfDaughters() );
            //cout<<" number of muons in triplet="<<TauIt->numberOfDaughters()<<endl;


	    ///////////////Check Trigger Matching///////////////
            float dR1 = 999., dR2 = 999., dR3 = 999.;
	    float dPtRel1 = 999., dPtRel2 = 999., dPtRel3 = 999.;
	    float dR1_2017 = 999., dR2_2017 = 999., dR3_2017 = 999.;
            float dR1_Mu7=999.,dR2_Mu7 = 999., dR3_Mu7 = 999.;
            float dR1_Mu8=999.,dR2_Mu8 = 999., dR3_Mu8 = 999.;
            float dR1_Mu8_IP6=999., dR1_Mu12_IP6=999, dR1_Mu8_IP5=999.;
            float dR1_Mu9_IP0=999., dR1_Mu9_IP3=999.,  dR1_Mu9_IP4=999., dR1_Mu9_IP5=999., dR1_Mu9_IP6=999.;
            std::vector<trigger::TriggerObject> trgobjs = triggerSummary->getObjects();
            trigger::TriggerObjectCollection MuonsObjects;
            edm::InputTag MuonFilterTag = edm::InputTag("hltdstau3muDisplaced3muFltr", "", "HLT");
            size_t MuonFilterIndex = (*triggerSummary).filterIndex(MuonFilterTag); //find the index corresponding to the event
            if(MuonFilterIndex < (*triggerSummary).sizeFilters()) { //check if the trigger object is present
            //save the trigger objetcs corresponding to muon leg
                const trigger::Keys &KEYS = (*triggerSummary).filterKeys(MuonFilterIndex);
                for (unsigned int ipart = 0; ipart < KEYS.size(); ipart++) {
                    trigger::TriggerObject foundObject = (trgobjs)[KEYS[ipart]];
                    MuonsObjects.push_back(foundObject);		    
                }
                dR1 = MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects);
                dR2 = MiniAna2017Tree::dRtriggerMatch(*mu2, MuonsObjects);
                dR3 = MiniAna2017Tree::dRtriggerMatch(*mu3, MuonsObjects);
		dPtRel1 = MiniAna2017Tree::dPtTriggerMatch(*mu1, MuonsObjects);
		dPtRel2 = MiniAna2017Tree::dPtTriggerMatch(*mu2, MuonsObjects);
		dPtRel3 = MiniAna2017Tree::dPtTriggerMatch(*mu3, MuonsObjects);


            }


	    Mu1_dRtriggerMatch.push_back(dR1);
            Mu2_dRtriggerMatch.push_back(dR2);
            Mu3_dRtriggerMatch.push_back(dR3);


	    Mu1_dPtReltriggerMatch.push_back(dPtRel1);
            Mu2_dPtReltriggerMatch.push_back(dPtRel2);
            Mu3_dPtReltriggerMatch.push_back(dPtRel3);



	    if( isBParking){
	      dR1_Mu8 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu8);
	      dR2_Mu8 =   MiniAna2017Tree::dRtriggerMatch(*mu2, MuonsObjects_BPMu8);
	      dR3_Mu8 =  MiniAna2017Tree::dRtriggerMatch(*mu3, MuonsObjects_BPMu8);
	      Mu1_dRtriggerMatch_Mu8.push_back(dR1_Mu8);
	      Mu2_dRtriggerMatch_Mu8.push_back(dR2_Mu8);
	      Mu3_dRtriggerMatch_Mu8.push_back(dR3_Mu8);

	      dR1_Mu7 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu7);
	      dR2_Mu7 =  MiniAna2017Tree::dRtriggerMatch(*mu2, MuonsObjects_BPMu7);
	      dR3_Mu7 =  MiniAna2017Tree::dRtriggerMatch(*mu3, MuonsObjects_BPMu7);

	      Mu1_dRtriggerMatch_Mu7.push_back(dR1_Mu7);
	      Mu2_dRtriggerMatch_Mu7.push_back(dR2_Mu7);
	      Mu3_dRtriggerMatch_Mu7.push_back(dR3_Mu7);


	      dR1_Mu8_IP5 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu8_IP5);

	      Mu1_dRtriggerMatch_Mu8_IP5.push_back(dR1_Mu8_IP5);

	      dR1_Mu8_IP6 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu8_IP6);

	      Mu1_dRtriggerMatch_Mu8_IP6.push_back(dR1_Mu8_IP6);

	      dR1_Mu9_IP0 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu9_IP0);

	      Mu1_dRtriggerMatch_Mu9_IP0.push_back(dR1_Mu9_IP0);

	      dR1_Mu9_IP3 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu9_IP3);

	      Mu1_dRtriggerMatch_Mu9_IP3.push_back(dR1_Mu9_IP3);

	      dR1_Mu9_IP4 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu9_IP4);

	      Mu1_dRtriggerMatch_Mu9_IP4.push_back(dR1_Mu9_IP4);

	      dR1_Mu9_IP5 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu9_IP5);

	      Mu1_dRtriggerMatch_Mu9_IP5.push_back(dR1_Mu9_IP5);

	      dR1_Mu9_IP6 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu9_IP6);

	      Mu1_dRtriggerMatch_Mu9_IP6.push_back(dR1_Mu9_IP6);

	      dR1_Mu12_IP6 =  MiniAna2017Tree::dRtriggerMatch(*mu1, MuonsObjects_BPMu12_IP6);

	      Mu1_dRtriggerMatch_Mu12_IP6.push_back(dR1_Mu12_IP6);


            }



            if(isMc){
	      bool isMatch1=false; bool isMatch2=false; bool isMatch3=false;
	      if( (mu1->simType() == reco::MatchedMuonFromHeavyFlavour) && (fabs(mu1->simMotherPdgId()) == 15) ){
		isMatch1=true;
	      }
	      if( (mu2->simType() == reco::MatchedMuonFromHeavyFlavour) && (fabs(mu2->simMotherPdgId()) == 15) ){
		isMatch2=true;
	      }
	      if( (mu3->simType() == reco::MatchedMuonFromHeavyFlavour) && (fabs(mu3->simMotherPdgId()) == 15) ){
		isMatch3=true;
	      }
                
                //    cout<<TripletIndex<<"Triplet Mass:"<<TauIt->mass()<<" pt="<<TauIt->pt()<<" vtx.x="<<TauIt->vx()<<" vtx x="<<TripletVtx.x()<<" chi2="<<TauIt->vertexChi2()<<" ndof="<<TauIt->vertexNdof()<<endl;
                // cout<<TripletIndex<<"--Muon 1 pt="<<mu1->pt()<<" Muon2 pt="<<mu2->pt()<<" Mu3 pt="<<mu3->pt()<<" "<<endl;
                if( isMatch1 && isMatch2 && isMatch3) {
		  //cout<<" Matched Triplets mass="<<TauIt->mass()<<endl;
                    GenMatchMu1_SimPt.push_back(mu1->simPt());
                    GenMatchMu2_SimPt.push_back(mu2->simPt());
                    GenMatchMu3_SimPt.push_back(mu3->simPt());
                    
                    GenMatchMu1_SimEta.push_back(mu1->simEta());
                    GenMatchMu2_SimEta.push_back(mu2->simEta());
                    GenMatchMu3_SimEta.push_back(mu3->simEta());
                    
                    GenMatchMu1_SimPhi.push_back(mu1->simPhi());
                    GenMatchMu2_SimPhi.push_back(mu2->simPhi());
                    GenMatchMu3_SimPhi.push_back(mu3->simPhi());
                    
                    GenMatchMu1_Pt.push_back(mu1->pt());
                    GenMatchMu2_Pt.push_back(mu2->pt());
                    GenMatchMu3_Pt.push_back(mu3->pt());
                    
                    GenMatchMu1_Eta.push_back(mu1->eta());
                    GenMatchMu2_Eta.push_back(mu2->eta());
                    GenMatchMu3_Eta.push_back(mu3->eta());
                    
                    GenMatchMu1_Phi.push_back(mu1->phi());
                    GenMatchMu2_Phi.push_back(mu2->phi());
                    GenMatchMu3_Phi.push_back(mu3->phi());
                    
                    
                }
                
                
                //GenVtx vars to be added
            }
            
            //Triplets Vars
            
            
            TripletVtx_x.push_back(TauIt->vx());
            TripletVtx_y.push_back(TauIt->vy());
            TripletVtx_z.push_back(TauIt->vz());
            
            TripletVtx_Chi2.push_back(TauIt->vertexChi2());
            TripletVtx_NDOF.push_back(TauIt->vertexNdof());
            
            Triplet_Mass.push_back(TauIt->mass());
            Triplet_Pt.push_back(TauIt->pt());
            Triplet_Eta.push_back(TauIt->eta());
            Triplet_Phi.push_back(TauIt->phi());
            Triplet_Charge.push_back(TauIt->charge());
            //Matrix covariance to be added!!!!
            
            //Refitted Vars
            //vector < TransientTrack > ttrks = TripletVtx.refittedTracks();
            
            ////


	    /*
	    typedef std::vector<reco::TransientTrack> TTVect;
	    std::vector<TTVect> TTVectContainer;
	    for (uint k=0; k<pvTrackMap_refitVec.size(); k++){
	      removeTracks( pvTrackMap_refitVec.at(k),  SVTrackRef);
	      cout<<" k="<<k<<" size after TrackRemoval="<<pvTrackMap_refitVec.at(k)
	      //std::vector<reco::TransientTrack> pvTracks_refitTmp;
	      //for ( TransientTrackMap::iterator pvTrack = pvTrackMap_refitVec.at(k).begin();  pvTrack != pvTrackMap_refitVec.at(k).end(); ++pvTrack ) {
	      //pvTracks_refitTmp.push_back(pvTrack->second);
	      //}  
	      //cout<<" pvTracks_refitTmp size"<<pvTracks_refitTmp.size()<<endl;
	      //TTVectContainer.push_back(pvTracks_refitTmp);
	    }
	    //cout<<"TTVectContainer size "<<TTVectContainer.size()<<endl;
	    */


	    //KalmanVertexFitter PV_fitter (true);
	    //TransientVertex PVertex = PV_fitter.vertex(pvTracks_refit);





	    /////////////PV Refit//////////////////////////////
	    //cout<<" pvTrackMap_refit size "<<pvTrackMap_refit.size()<<endl;

            /*for(uint i=0; i<pvTracks_refit.size(); i++){
             TrackRef tr = TrackRef(pvTracks_refit, i);
             //reco::Track pvTr=pvTracks_refit.at(i).track();
             //TrackRef pvTrRef = pvTr.get<TrackRef>();
             cout<<i<<"PV track ID="<<tr.id()<<endl;
             }*/
	    /////////////PV Refit//////////////////////////////

            //Defining ISO VAR related to the triplet
            math::XYZPoint SVertexPoint = math::XYZPoint(TripletVtx.x(), TripletVtx.y(), TripletVtx.z());
            TLorentzVector LV1=TLorentzVector( mu1->px(), mu1->py(), mu1->pz(), mu1->energy() );
            TLorentzVector LV2=TLorentzVector( mu2->px(), mu2->py(), mu2->pz(), mu2->energy() );
            TLorentzVector LV3=TLorentzVector( mu3->px(), mu3->py(), mu3->pz(), mu3->energy() );
            TLorentzVector LVTau = LV1 + LV2 + LV3;


            edm::View<reco::Track>::const_iterator trIt  = trackCollection->begin();
            edm::View<reco::Track>::const_iterator trEnd = trackCollection->end();

            int nTracks03_mu1=0, nTracks03_mu2=0, nTracks03_mu3=0;
            double mindist=9999;
            double sumPtTrack1=0, sumPtTrack2=0, sumPtTrack3=0, maxSumPtTracks=0;
            for (; trIt != trEnd; ++trIt) {
               const reco::Track track = (*trIt);
               if(  (track.pt()>1) && (fabs(track.eta())<2.4) && (track.hitPattern().trackerLayersWithMeasurement()>5) && (track.hitPattern().pixelLayersWithMeasurement()>1)  ){
                  double dR1 = dR(Track1.eta(), track.eta(), Track1.phi(), track.phi() );
                  double dR2 = dR(Track2.eta(), track.eta(), Track2.phi(), track.phi() );
                  double dR3 = dR(Track3.eta(), track.eta(), Track3.phi(), track.phi() );
                  //if (dR1 == 0 || dR2 == 0 || dR3 == 0) { 
		  //cout<<"Skip muon track"<<endl; 
		  if (dR1 < 0.01 || dR2 < 0.01 || dR3 < 0.01) { 
		    continue;}
                  double dz = abs(track.dz(SVertexPoint));
                  double dxy = abs(track.dxy(SVertexPoint));
                  double dca_fv = sqrt(dz*dz+dxy*dxy);
                  if(dca_fv<mindist && dca_fv>0) { 
		    
		    mindist = dca_fv;
		    //	    cout<<" MinDist="<<dca_fv<<endl; 
		  }
		  
                  //for eack track having pt>1, excluded the muon tracks,
                  //for each muon in the triplet, if deltaR<0.3 and the DCA is smaller than 1 mm
                  //the pt of the track is added -> I will take the largest total pt from the three muons
                  if (dca_fv < 0.1) {
                     if (dR1<0.3) {
                        sumPtTrack1+=track.pt();
                        nTracks03_mu1++;
                     }
                     if (dR2<0.3) {
                        sumPtTrack2+=track.pt();
                        nTracks03_mu2++;
                     }
                     if (dR3<0.3) {
                        sumPtTrack3+=track.pt();
                        nTracks03_mu3++;
                     }
                  }
               }
            }
            Triplet_mindca_iso.push_back(mindist);
            maxSumPtTracks = std::max(sumPtTrack1, std::max(sumPtTrack2,sumPtTrack3));
	    //cout<<TripletIndex<<" TauMass "<<TauIt->mass()<<" SumPt Tracks in cone="<<maxSumPtTracks<<" TauPt="<<TauIt->pt()<<endl;
            double relativeiso = maxSumPtTracks/LVTau.Pt();
            Triplet_relativeiso.push_back(relativeiso);
            
            Mu1_NTracks03iso.push_back(nTracks03_mu1);
            Mu2_NTracks03iso.push_back(nTracks03_mu2);
            Mu3_NTracks03iso.push_back(nTracks03_mu3);

	    double sumPtTrackRel1=0, sumPtTrackRel2=0, sumPtTrackRel3=0, maxSumPtRelTracks =0;
            sumPtTrackRel1=sumPtTrack1/LV1.Pt();
            sumPtTrackRel2=sumPtTrack2/LV2.Pt();
            sumPtTrackRel3=sumPtTrack3/LV3.Pt();
	    maxSumPtRelTracks = std::max(sumPtTrackRel1, std::max(sumPtTrackRel2,sumPtTrackRel3));
	    Triplet_relativeiso2.push_back(maxSumPtRelTracks);
	    Triplet_IsoMu1.push_back(sumPtTrack1);
            Triplet_IsoMu2.push_back(sumPtTrack2);
            Triplet_IsoMu3.push_back(sumPtTrack3);

 
	    //Cout<<"Valid Vtx2="<<PVertex.isValid()<<endl;
	    //CachingVertex<5> fittedVertex = vertexFitter.vertex(tracksToVertex);
	    GlobalPoint PVertexPos  (PVertex.position());
	    GlobalPoint SVertexPos  (TripletVtx.x(), TripletVtx.y(), TripletVtx.z());
	    //cout<<" PV Coord after refit="<<PVertexPos.x()<<" y="<<PVertexPos.y()<<" z="<<PVertexPos.z()<<endl;
	    double FlightDist = TMath::Sqrt( pow(( PVertexPos.x() -SVertexPos.x()),2)+ pow(( PVertexPos.y() -SVertexPos.y()),2) + pow(( PVertexPos.z() -SVertexPos.z()),2));
                    
	    VertexDistance3D vertTool;
	    VertexState PVstate(PVertex.position(),PVertex.positionError());
	    //VertexState SVstate(SVertexPos,TripletVtx.position());
	    double distance = vertTool.distance(PVstate, TripletVtx).value();
	    double dist_err = vertTool.distance(PVstate, TripletVtx).error();
	    double dist_sign =vertTool.distance(PVstate, TripletVtx).significance();
	    double chi2 = vertTool.compatibility(PVstate, TripletVtx);
                    
	    
	    //VertexDistance3D dist;
	    //double fv_d3D = dist.distance(Vertex(fv), pvv).value(); // = dv_reco.Mag() ??
	    //double fv_d3Dsig = dist.distance(Vertex(fv), pvv).significance();
	    //double fv_ppdl3D = fv_d3D*fv_cosdphi3D*m3mu_reco/vtau.P();
	    
	    VertexState BSstate(beamSpot);
	    VertexDistanceXY vertTool2D;
	    double BSdistance2D = vertTool2D.distance(BSstate, TripletVtx).value();
	    double BSdist_err2D = vertTool2D.distance(BSstate, TripletVtx).error();
	    double BSdist_sign2D =vertTool2D.distance(BSstate, TripletVtx).significance();
	    
	    PV_x.push_back( (*vertices)[primaryvertex_index].x());
	    PV_y.push_back( (*vertices)[primaryvertex_index].y());
	    PV_zcance_PVSV", &DistXY_significance_PVSV


	if( isBParking){
	  tree_->Branch("MuonPt_HLT_BPMu7", &MuonPt_HLT_BPMu7);
	  tree_->Branch("MuonEta_HLT_BPMu7", &MuonEta_HLT_BPMu7);
	  tree_->Branch("MuonPhi_HLT_BPMu7", &MuonPhi_HLT_BPMu7);
	  tree_->Branch("MuonPt_HLT_BPMu8", &MuonPt_HLT_BPMu8);
	  tree_->Branch("MuonEta_HLT_BPMu8", &MuonEta_HLT_BPMu8);
	  tree_->Branch("MuonPhi_HLT_BPMu8", &MuonPhi_HLT_BPMu8);
	  tree_->Branch("MuonPt_HLT_BPMu8_IP6", &MuonPt_HLT_BPMu8_IP6);
	  tree_->Branch("MuonEta_HLT_BPMu8_IP6", &MuonEta_HLT_BPMu8_IP6);
	  tree_->Branch("MuonPhi_HLT_BPMu8_IP6", & MuonPhi_HLT_BPMu8_IP6);
	  tree_->Branch("MuonPt_HLT_BPMu8_IP5", &MuonPt_HLT_BPMu8_IP5);
	  tree_->Branch("MuonEta_HLT_BPMu8_IP5", &MuonEta_HLT_BPMu8_IP5);
	  tree_->Branch("MuonPhi_HLT_BPMu8_IP5", &MuonPhi_HLT_BPMu8_IP5);
	  tree_->Branch("MuonPt_HLT_BPMu9_IP0", &MuonPt_HLT_BPMu9_IP0);
	  tree_->Branch("MuonEta_HLT_BPMu9_IP0", &MuonEta_HLT_BPMu9_IP0);
	  tree_->Branch("MuonPhi_HLT_BPMu9_IP0", &MuonPhi_HLT_BPMu9_IP0);
	  tree_->Branch("MuonPt_HLT_BPMu3_IP3", &MuonPt_HLT_BPMu3_IP3);
	  tree_->Branch("MuonEta_HLT_BPMu3_IP3", &MuonEta_HLT_BPMu3_IP3);

	  tree_->Branch("MuonPhi_HLT_BPMu3_IP3", &MuonPhi_HLT_BPMu3_IP3);
	  tree_->Branch("MuonPt_HLT_BPMu3_IP4", &MuonPt_HLT_BPMu3_IP4);
	  tree_->Branch("MuonEta_HLT_BPMu3_IP4", &MuonEta_HLT_BPMu3_IP4);
	  tree_->Branch("MuonPhi_HLT_BPMu3_IP4", &MuonPhi_HLT_BPMu3_IP4);
	  tree_->Branch("MuonPt_HLT_BPMu3_IP5", &MuonPt_HLT_BPMu3_IP5);
	  tree_->Branch("MuonEta_HLT_BPMu3_IP5", &MuonEta_HLT_BPMu3_IP5);
	  tree_->Branch("MuonPhi_HLT_BPMu3_IP5", &MuonPhi_HLT_BPMu3_IP5);
	  tree_->Branch("MuonPt_HLT_BPMu3_IP6", &MuonPt_HLT_BPMu3_IP6);
	  tree_->Branch("MuonEta_HLT_BPMu3_IP6", &MuonEta_HLT_BPMu3_IP6);
	  tree_->Branch("MuonPhi_HLT_BPMu3_IP6", &MuonPhi_HLT_BPMu3_IP6);
	  tree_->Branch("MuonPt_HLT_BPMu12_IP6", &MuonPt_HLT_BPMu12_IP6);
	  tree_->Branch("MuonEta_HLT_BPMu12_IP6", &MuonEta_HLT_BPMu12_IP6);
	  tree_->Branch("MuonPhi_HLT_BPMu12_IP6", &MuonPhi_HLT_BPMu12_IP6);


	  tree_->Branch("Mu1_dRtriggerMatch_Mu7", &Mu1_dRtriggerMatch_Mu7);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu8", &Mu1_dRtriggerMatch_Mu8);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu8_IP5", &Mu1_dRtriggerMatch_Mu8_IP5);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu8_IP6", &Mu1_dRtriggerMatch_Mu8_IP6);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu9_IP0", &Mu1_dRtriggerMatch_Mu9_IP0);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu9_IP3", &Mu1_dRtriggerMatch_Mu9_IP3);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu9_IP4", &Mu1_dRtriggerMatch_Mu9_IP4);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu9_IP5", &Mu1_dRtriggerMatch_Mu9_IP5);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu9_IP6", &Mu1_dRtriggerMatch_Mu9_IP6);
	  tree_->Branch("Mu1_dRtriggerMatch_Mu12_IP6", &Mu1_dRtriggerMatch_Mu12_IP6);
	  tree_->Branch("Mu2_dRtriggerMatch_Mu7", &Mu2_dRtriggerMatch_Mu7);
	  tree_->Branch("Mu2_dRtriggerMatch_Mu8", &Mu2_dRtriggerMatch_Mu8);

	  tree_->Branch("Mu3_dRtriggerMatch_Mu7", &Mu3_dRtriggerMatch_Mu7);
	  tree_->Branch("Mu3_dRtriggerMatch_Mu8", &Mu3_dRtriggerMatch_Mu8);


	}

        /*  SyncTree_ = fs->make<TTree>("t","Sync ntuple");
         SyncTree_ ->Branch("allmuons_pt",&allmuons_pt);
         SyncTree_->Branch("leadmuon_pt",&leadmuon_pt);
         SyncTree_->Branch("leadmuon_phi",&leadmuon_phi);
         SyncTree_->Branch("leadmuon_eta",&leadmuon_eta);
         SyncTree_->Branch("nmuons",&nmuons);
         SyncTree_->Branch("nprimevtxs",&nprimevtxs); 
         
         SyncTree_->Branch("leadtrack_pt", &leadtrack_pt);
         SyncTree_->Branch("leadtrack_eta", &leadtrack_eta);
         SyncTree_->Branch("leadtrack_phi", &leadtrack_phi);
         SyncTree_->Branch("alltracks_pt", &alltracks_pt);
         SyncTree_->Branch("evt", &evt);
         SyncTree_->Branch("run", &run);
         SyncTree_->Branch("lumi", &lumi);
         */
        
        
        
    }
    
    
    // ------------ method called once each job just after ending the event loop  ------------
    void 
    MiniAna2017Tree::endJob() 
    {
        //  tree_->GetDirectory()->cd();
        tree_->Write();
        
        //  SyncTree_->GetDirectory()->cd();
        //  SyncTree_->Write();
        
    }
    
    // ------------ method fills 'descriptions' with the allowed parameters for the module  ------------
    
    
    void MiniAna2017Tree::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
        //The following says we do not know what parameters are allowed so do no validation
        // Please change this to state exactly what you do use, even if it is no parameters
        edm::ParameterSetDescription desc;
        desc.setUnknown();
        descriptions.addDefault(desc);
    }
    //define this as a plug-in
    DEFINE_FWK_MODULE(MiniAna2017Tree);
